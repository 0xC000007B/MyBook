###面向对象的思想

***

_概述_
*面向对象是一种程序设计的思想，通常我们进行一个程序的设计要进行的步骤大体要经过需求、分析、设计、编码、测试。*

---
###什么是对象？
+ 一个事件可以是一个对象，一个错误也可以是一个对象，若干个小对象组合在一起可以形成一个大的对象。
+ 通常我们定义的方法就可以成为一个对象的功能。
+ 对象之间通过方法之间的调用来互相联系。
+ 除了8个基本数据类型值之外，一切都是对象。

---
###在我们书写一个对象的时候需要注意的一些规则：
+ 代码的功能越简单越好，简单的说就是各司其职
+ 尽量让对象之间的耦合性尽可能的弱
+ 考虑对象的可重用性和可扩展性
---
**我们说的对象，一般的来说就是客观存在的事物，而类则是客观事物在人脑中的反映，可以说是对对象的抽象或是对象的模板。**

![01](01)

***
###方法的定义
**一个方法有两部分：方法的定义（声明）和方法的实现。**

+ 方法的声明
	+ 修饰符 返回值 方法名（参数表） 抛出的异常
	+ 这里需要注意的是一个方法可以有多个修饰符，谁在前谁在后都无所谓

+ 方法的实现
	+ 方法的重载：overloading
		方法的重载就是允许在一个类的里面写多个方法名相同，但参数表不同的方法：
        void m(){};
        void m（int  a）;
        void m(int a, int b);
        void m(double a);
        void (string s);
        void m(int a,string b);
        void m(string b,int a);
        //Void m(string s , int k)   {}error  注意光是参数名不同不是重载
        所以方法重载又叫编译时多态，方法的重载是编译器决定。它的作用是一个对象的同类方法由于参数表的不同造成的差异对于对象使用者屏蔽。
        Testoverload
        byte b=10;
        m(b);
        \\Void m(byte a);    向上就近匹配原则  输出 short
        Void m(int a);
        Void m(short a);
        Java 中类和方法的位置是没有关系的，  所以一定要注意引用明确。

	+ 覆盖
		+ 覆盖常用的一个地方就是类的构造，通常我们会使用它来覆盖父类的构造方法，，构造方法是不能手工调用的，是自动调用的，是在对象构造时自动调用一次。
		+ 注意写构造方法时是不需要有返回值。
		+ 而且方法的方法名是有限制的，方法名必须和类名相同，Public student();

###类的构造过程
+ 分配空间：根据属性的多少
+ 初始化属性
+ 调用某一个构造方法
+ 构造方法  经常用来给属性赋值。
+ 这里需要知道，如果一个类你没有写任何构造方法，系统就会提供一个默认的无参的空构造方法，这是因为任何类都要有一个构造方法。
+ 这里涉及到一个垃圾回收的问题，如果一个对象没有被其他对象所引用实例化的时候才会被垃圾回收。

![02](02)

+ 覆盖的意义：对从父类中继承的方法的发展。
+ **注意：父子类中有同名的属性不叫子类覆盖父类的属性，叫做属性的遮盖（shadow）。**

***

+ this

主要用来是指向对象，我们知道在java中简单变量传递的是值，而对象变量力面转载的是一个地址，在编码的过程总我们可能需要大量的使用引用的地址，很多时候我们需要this这个关键字来区分实例变量和局部变量（形参也相当于局部变量）。

    	class A{
        	int a;
    		public void b(){
    		int c;
    		c= this.a;
   			}
    	}


第二种情况是我们要调用本类被的其他构造方法的时候我们同亚

	class A{
    	public A(){}
        public A(){
        	this();
        }
    }

+ super

	- super()，表示在子类的构造方法中调用父类的构造方法（可以通过这种方法在子类的构造方法中初始化父类中的属性），super()也只能出现在构造方法的第一句上.super(),在子类的构造方中指明构造父类时调用哪一个父类的构造方法构造父类。
	- super,这里所表示的是一个父类的对象，可以通过super来使用父类中可以访问的方法（可以在父类中定义setXxx()，getXxx()方法来访问父类中的私有属性），super可以屏蔽父子类中同名属性的冲突。
	- 注意：在写类的时候，一定要写默认无参的构造方法，如果一个构造方法的第一句既不是this(),也不是super()时，那么就会在这里隐含的调用他的父类的无参的构造方法，即隐含的有super()。
	- 少覆盖原则：既子类应当尽量少的覆盖父类方法，如果覆盖了父类的大多数方法，那就应当考虑是否应当有继承关系

![03](03)

***

[01]:/corejava/chapter3/01.jpg
[02]:/corejava/chapter3/02.jpg
[03]:/corejava/chapter3/03.jpg



